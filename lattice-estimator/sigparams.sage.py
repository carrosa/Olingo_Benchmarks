

# This file was *autogenerated* from the file sigparams.sage
from sage.all_cmdline import *   # import sage library

_sage_const_256 = Integer(256); _sage_const_1024 = Integer(1024); _sage_const_1023 = Integer(1023); _sage_const_0 = Integer(0); _sage_const_128 = Integer(128); _sage_const_7 = Integer(7); _sage_const_10 = Integer(10); _sage_const_192 = Integer(192); _sage_const_13 = Integer(13); _sage_const_12 = Integer(12); _sage_const_16 = Integer(16); _sage_const_0p01 = RealNumber('0.01'); _sage_const_1p01 = RealNumber('1.01'); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_60 = Integer(60); _sage_const_38 = Integer(38); _sage_const_41 = Integer(41); _sage_const_36 = Integer(36); _sage_const_40 = Integer(40); _sage_const_35 = Integer(35); _sage_const_20 = Integer(20); _sage_const_4 = Integer(4); _sage_const_56 = Integer(56); _sage_const_17 = Integer(17); _sage_const_21 = Integer(21); _sage_const_25 = Integer(25); _sage_const_3 = Integer(3); _sage_const_0p667 = RealNumber('0.667'); _sage_const_8000 = Integer(8000); _sage_const_8000000 = Integer(8000000); _sage_const_2659 = Integer(2659); _sage_const_89 = Integer(89); _sage_const_105p22 = RealNumber('105.22'); _sage_const_120p22 = RealNumber('120.22'); _sage_const_193 = Integer(193); _sage_const_250p75 = RealNumber('250.75'); _sage_const_303 = Integer(303); _sage_const_66 = Integer(66)
import os
#os.chdir("/Users/phmbp2025/Desktop/lwe-estimator")

from estimator import *


#security parameter

secpar = _sage_const_256 

print("Security level: ", secpar)


# threshold sizes

n = _sage_const_1024 
t = _sage_const_1023 

print("Threshold (n, t)=", "(", n, ",", t,")")

# ring dimension, module dimension, sec dimension, tail bound

ringdim = _sage_const_256 

moddim = _sage_const_0 
secdim = _sage_const_0 

if secpar == _sage_const_128 : 
	moddim = _sage_const_7 
	secdim = _sage_const_10 

if secpar == _sage_const_192 : 
	moddim = _sage_const_10 
	secdim = _sage_const_13 

if secpar == _sage_const_256 : 
	moddim = _sage_const_12 
	secdim = _sage_const_16 

# Setting cut-off point for truncated gaussian sampling

rej_rate = _sage_const_0p01 

tail_bound = _sage_const_0p01 
tail_bound_2 = _sage_const_1p01 

while (_sage_const_2  * exp((-tail_bound**_sage_const_2 ) / _sage_const_2 )) > rej_rate:
    tail_bound = tail_bound + _sage_const_0p01 

while ((tail_bound_2**ringdim)*exp((ringdim/_sage_const_2 )*(_sage_const_1 -tail_bound_2**_sage_const_2 ))) > rej_rate:
    tail_bound_2 = tail_bound_2 + _sage_const_0p01 


# Total number of signatures

Q = _sage_const_2 **_sage_const_60 

# Bit-dropping parameters 

if secpar==_sage_const_128 :
	kappa_y = _sage_const_38 
	kappa_w = _sage_const_41 
if secpar==_sage_const_192 :
	kappa_y = _sage_const_36 
	kappa_w = _sage_const_40 
if secpar==_sage_const_256 :
	kappa_y = _sage_const_35 
	kappa_w = _sage_const_41 

# Gaussian widths for s and r, set according to Raccoon analysis


if secpar==_sage_const_128 :
	sigma_r = _sage_const_2 **_sage_const_38 
	sigma_s = _sage_const_2 **_sage_const_20 
if secpar==_sage_const_192 :
	sigma_r = _sage_const_2 **_sage_const_38 
	sigma_s = _sage_const_2 **_sage_const_20 
if secpar==_sage_const_256 :
	sigma_r = _sage_const_2 **_sage_const_38 
	sigma_s = _sage_const_2 **_sage_const_20 


# Defining challenge space 1-norm

nu = _sage_const_0 
while ((_sage_const_2 **nu) * binomial(ringdim,nu) <_sage_const_2 **secpar):
    nu = nu + _sage_const_1 


# Hint-MLWE bound

B_HMLWE = Q * nu * (_sage_const_1 +ringdim*(secpar+_sage_const_1 +_sage_const_2  * log(ringdim,_sage_const_2 ))/sqrt(Q))

assert(nu*_sage_const_2 **kappa_y+_sage_const_2 **(kappa_w+_sage_const_1 ) <= sigma_r * sqrt(t * (_sage_const_1 +moddim/secdim)))

assert(sigma_s <= sigma_r/nu)


# Gaussian width for MLWE security

sigma = sqrt(_sage_const_1 /(_sage_const_2 /(n*sigma_s**_sage_const_2 ) + _sage_const_2 *B_HMLWE/(t*sigma_r**_sage_const_2 )))

B = e**(_sage_const_1 /_sage_const_4 ) * (nu * sigma_s * n  + t * sigma_r)*sqrt(ringdim * (moddim + secdim)) + (nu * (_sage_const_2 **kappa_y) + _sage_const_2 **(kappa_w+_sage_const_1 )) * sqrt(ringdim * moddim)

#print("B_2z =", log(B,2).n())

B_STMSIS = B + sqrt(nu) + (nu * (_sage_const_2 **(kappa_y)) + _sage_const_2 **(kappa_w + _sage_const_1 )) * sqrt(ringdim * moddim)
#print("B_STMSIS = ", log(B_STMSIS,2).n(), "bits")

B_MSIS = B_STMSIS - nu #Following Raccoon parameter selection recommendation

print("B_MSIS bits =", log(B_MSIS,_sage_const_2 ).n())

B_inf =  sqrt(ringdim) * tail_bound * sigma_s * sqrt(n) + tail_bound * sigma_r * sqrt(t)

# Setting signature Modulus

if secpar == _sage_const_128 :
	logq = _sage_const_56 

if secpar == _sage_const_192 :
	logq = _sage_const_56 

if secpar == _sage_const_256 :
	logq = _sage_const_56 


q = round(_sage_const_2 **logq)
while  (q % (_sage_const_2 *ringdim) != _sage_const_1 ) or (gcd(q-_sage_const_1 , _sage_const_2 *ringdim) == _sage_const_1 ):   #setting for NTT friendliness
	q = next_prime(q)

print("Signature parameters: ", "( N =", ringdim, ", q bits=", round(log(q,_sage_const_2 )), ", #sigs = 2^",log(Q,_sage_const_2 ), ", chalspace 1-norm =", nu, ", k_y =", kappa_y, ", k_w =", kappa_w, ", mod dim =", moddim, ", sec dim =", secdim, ", sigma_y =", log(sigma_s,_sage_const_2 ), ", sigma_w =", log(sigma_r,_sage_const_2 ), ")")

# Security check

#LWE for partial signing key
y_lwe_param = LWE.Parameters(n=ringdim*moddim, q=q, Xs=ND.DiscreteGaussian(sigma_s), Xe=ND.DiscreteGaussian(sigma_s), tag='Partial Signature Key LWE')

#LWE for partial commitment
w_lwe_param = LWE.Parameters(n=ringdim*moddim, q=q, Xs=ND.DiscreteGaussian(sigma_r), Xe=ND.DiscreteGaussian(sigma_r), tag='Partial Commitment LWE')

#LWE for combined signature 
lwe_param = LWE.Parameters(n=ringdim*moddim, q=q, Xs=ND.DiscreteGaussian(sigma), Xe=ND.DiscreteGaussian(sigma), tag='Combined Signature LWE')
print()

#print(log(B_MSIS,2).n())
assert(B_MSIS < (q-_sage_const_1 )/_sage_const_2 )

#SIS for security
sis_param = SIS.Parameters(n=(secdim)*ringdim, q=q, length_bound=B_MSIS, m=(moddim+secdim+_sage_const_1 )*ringdim, norm=_sage_const_2 , tag='Signature SIS')

print("----------")
print("Start LWE estimation")
print("----------")
print()

print("LWE Sec. of partial signing key")
y_lwe = LWE.estimate.rough(y_lwe_param)
print()
print("LWE Sec. of partial commitment")
w_lwe = LWE.estimate.rough(w_lwe_param)
print()

print("LWE Sec. of combined signature")
r_lwe = LWE.estimate.rough(lwe_param)
print()

print("Combined LWE for Hint LWE:")
print(r_lwe)
print()

print("----------")
print("Start SIS estimation")
print("----------")
print()

r_sis = SIS.estimate.rough(sis_param)

print("SIS for SelfTargetSIS")
print(r_sis)
print()


# Set parameters for encryption scheme
print("----------")
print("Start HE Parameters")
print("----------")
print()
p = q

# params for granular adjustment of security level
expansionfactor = _sage_const_4  
adjust_factor = _sage_const_0 

if secpar == _sage_const_128 :
	adjust_factor = _sage_const_17 
if secpar == _sage_const_192 :
	adjust_factor = _sage_const_21 
if secpar == _sage_const_256 :
	adjust_factor = _sage_const_25 

#secdimhat = secdim * expansionfactor
#moddimhat = moddim * expansionfactor

m = round(secdim * expansionfactor - adjust_factor)

secdimhat = m
moddimhat = m

sigma_ctx = sqrt(_sage_const_2 /_sage_const_3 )
sigma_B = sqrt(_sage_const_2 /_sage_const_3 )

B_2 = nu * n * moddimhat * tail_bound_2 * sigma_B * ringdim * tail_bound_2 * sigma_ctx + n * nu * p * tail_bound_2 * sigma_ctx*sqrt(ringdim) + p * nu * n * secdimhat * tail_bound_2 *sigma_B * ringdim * tail_bound_2 * sigma_ctx + t * tail_bound_2 * sigma_B * ringdim * tail_bound_2 * sigma_ctx * moddimhat + p * t * tail_bound_2 * sigma_ctx * sqrt(ringdim) + t * p * secdimhat * tail_bound_2 * sigma_B * ringdim *tail_bound_2 * sigma_ctx

sigma_tdec = sqrt(Q * B_2**_sage_const_2  / p**_sage_const_2 )

B_dec = nu * n * tail_bound_2 * sigma_s * sqrt(ringdim * secdim) + t * tail_bound_2 * sigma_r * sqrt(ringdim * secdim) +B_2 + p * t * tail_bound_2 * sigma_tdec 
q_enc = ((B_dec) * _sage_const_2 ).n()
while  (q_enc % (_sage_const_2 *ringdim) != _sage_const_1 ) or (gcd(q_enc-_sage_const_1 , _sage_const_2 *ringdim) == _sage_const_1 ):
	q_enc = next_prime(q_enc)
q_enc_actual = q_enc
log_q_enc = log(q_enc_actual,_sage_const_2 )
#print("q_enc:",N(q_enc_actual))
#print("q_enc:",str(q_enc_actual))
#print("log q_enc:", N(log_q_enc))

print("HE parameters: ", "( N =", ringdim, ", qhat bits=", N(log_q_enc,_sage_const_4 ), ", secdimhat =", secdimhat, ", moddimhat = ", moddimhat, ", m = ", m, ", secdim = ", secdim, ", moddim = ", moddim, ")")


v_enc_lwe_param = LWE.Parameters(n=ceil(ringdim*m), q=q_enc_actual, Xs=ND.DiscreteGaussian(sigma_ctx), Xe=ND.DiscreteGaussian(sigma_ctx),m=_sage_const_2 **_sage_const_60 , tag='HE LWE v')
u_enc_lwe_param = LWE.Parameters(n=ceil(ringdim*secdimhat), q=q_enc_actual, Xs=ND.DiscreteGaussian(sigma_ctx), Xe=ND.DiscreteGaussian(sigma_ctx),m=_sage_const_2 **_sage_const_60 , tag='HE LWE u')
pk_enc_lwe_param = LWE.Parameters(n=ceil(ringdim*moddimhat), q=q_enc_actual, Xs=ND.DiscreteGaussian(sigma_B), Xe=ND.DiscreteGaussian(sigma_B), tag='HE LWE Public Key')

print()
print("----------")
print("Start HE LWE estimation")
print("----------") 
print()

print("LWE Sec. of cipher text element 'v'")
v_lwe = LWE.estimate.rough(v_enc_lwe_param)
print()

print("LWE Sec. of cipher text element 'u'")
u_lwe = LWE.estimate.rough(u_enc_lwe_param)
print()

print("LWE Sec. encryption pk")
pk_lwe = LWE.estimate.rough(pk_enc_lwe_param)
print()


print("----------")
print("BDLOP Commitment Params")
print("----------")
print()

print("Computing hiding hardness:")
sig_com_rand = _sage_const_0p667 
A1_height = _sage_const_1 
A2_height = m
A1_A2_width = A1_height+A2_height+_sage_const_1 
com_hiding_param = LWE.Parameters(n=ceil(ringdim*(A1_height+A2_height)), q=q_enc_actual, Xs=ND.DiscreteGaussian(sig_com_rand), Xe=ND.DiscreteGaussian(sig_com_rand), tag='com hiding')
com_hiding = LWE.estimate.rough(com_hiding_param)
print(com_hiding)


print()
print("Computing binding hardness:")
B_com_rand = _sage_const_16 *sig_com_rand*sqrt(nu*ringdim)
print(f"{B_com_rand=}")
sis_param = SIS.Parameters(n=(A1_height)*ringdim, q=q_enc_actual, length_bound=B_com_rand, m=ringdim*A1_A2_width, norm=_sage_const_2 , tag='Signature SIS')
com_sis = SIS.estimate.rough(sis_param)
print(com_sis)



print()
print("----------")
print("Computing sizes")
print("----------")
print()

# Compute sizes in bits

challenge = ringdim * _sage_const_1 
response = ringdim * (secdim) * ceil(log(B_inf,_sage_const_2 ))
hint = ringdim * moddim * ceil(log(B/(_sage_const_2 **kappa_w * sqrt(ringdim * (moddim))),_sage_const_2 ))

signature = challenge + response + hint
pk = ringdim * moddim * (logq - kappa_y) + secpar

print("SIG size in KB:", N(signature/_sage_const_8000 ,digits=_sage_const_4 ))
print("PK size in KB:", N(pk/_sage_const_8000 ,digits=_sage_const_4 ))
print()

##### DKG Passive sizing sizes #######

h_i = _sage_const_256 
B_i = moddimhat * m * ringdim * log(q,_sage_const_2 )
B_ij = moddimhat * m * ringdim * log(q,_sage_const_2 )
S_ij = secdimhat * m * ringdim * log(q,_sage_const_2 )
E_ij = moddimhat * m * ringdim * log(q,_sage_const_2 )

DKG_comcostbits = h_i + B_i + n*B_ij + n*S_ij + n*E_ij 

DKG_comcost = (DKG_comcostbits/_sage_const_8000000 ).n()

print("DKG passive com cost=", DKG_comcost, "MB")
print()

##### Passive signing sizing sizes #######

 
hash_w_size = ringdim
w_size = moddim*ringdim*logq
ctx_r_size = (secdimhat+m)*ringdim*log_q_enc
decshare_size = m*ringdim*log_q_enc

decshare_size_bits=(decshare_size/_sage_const_8000 ).n()

print("DecShare_Cost =" f"{decshare_size_bits:.2f}", "KB")

ComCost_Passive = ((round(hash_w_size + w_size + ctx_r_size + decshare_size))/_sage_const_8000 ).n()
print()
print("Passive signing communication cost = ", f"{ComCost_Passive:.2f}", "KB")
print()


###### pi_dsi proof size ######
sig_pi_dsi = _sage_const_2659 
com_E = N((m+_sage_const_1 )*ringdim*log(q_enc,_sage_const_2 )/_sage_const_8000 ,digits=_sage_const_4 )
#print("Com(E) in KB:", com_E)
z_E = (m+_sage_const_3 )*ringdim*log(tail_bound*sig_pi_dsi,_sage_const_2 )
#print("z_E cost in KB: ", N(z_E/8000,digits=4))
z_S = (m+_sage_const_3 )* m *ringdim * log(tail_bound*sig_pi_dsi,_sage_const_2 )
#print("z_S cost in KB: ", N(z_S/8000,digits=4))
pi_LIN_dsi = N((challenge + z_E + z_S)/_sage_const_8000 ,digits=_sage_const_4 )
#print("pi_LIN_dsi cost in KB: ", pi_LIN_dsi)


# LNP proofs calculated externally using LaZer library

LNP_dsi=_sage_const_0 
if secpar == _sage_const_128 : 
	LNP_dsi=_sage_const_89 
if secpar == _sage_const_192 : 
	LNP_dsi=_sage_const_105p22 
if secpar == _sage_const_256 : 
	LNP_dsi=_sage_const_120p22 

LNP_ri=_sage_const_0 
if secpar == _sage_const_128 : 
	LNP_ri=_sage_const_193 
if secpar == _sage_const_192 : 
	LNP_ri=_sage_const_250p75 
if secpar == _sage_const_256 : 
	LNP_ri=_sage_const_303 

pi_dsi = com_E + pi_LIN_dsi + LNP_dsi
print("Final round proof cost in KB: ", pi_dsi)

print("Active signing cost =", f"{ComCost_Passive + pi_dsi + LNP_ri:.2f}", "KB") 
print("Online signing cost =", f"{decshare_size_bits + pi_dsi :.2f}", "KB") 
print("Online signing cost with LaBRADOR =", f"{decshare_size_bits + com_E + pi_LIN_dsi + _sage_const_66  :.2f}", "KB") 
print("Active signing cost using LaBRADOR =", f"{ComCost_Passive + _sage_const_66  + LNP_ri:.2f}", "KB") 
print("Optimistic signing cost =", f"{decshare_size_bits:.2f}", "KB")




print("Done")


